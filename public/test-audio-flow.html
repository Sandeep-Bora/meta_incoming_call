<!DOCTYPE html>
<html>
<head>
    <title>Audio Flow Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        #status { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 3px; }
        audio { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Audio Flow Test</h1>
    <p>This page tests if the browser can receive and play audio from the server properly</p>

    <div class="test-section">
        <h3>Test 1: Direct Audio Element Test</h3>
        <button onclick="testDirectAudio()">Test Direct Audio</button>
        <audio id="testAudio" controls></audio>
        <div id="directStatus"></div>
    </div>

    <div class="test-section">
        <h3>Test 2: WebRTC Audio Reception Test</h3>
        <button onclick="testWebRTCAudio()">Test WebRTC Audio</button>
        <audio id="webrtcAudio" controls autoplay></audio>
        <div id="webrtcStatus"></div>
    </div>

    <div class="test-section">
        <h3>Test 3: Microphone Loopback Test</h3>
        <button onclick="testMicLoopback()">Test Mic Loopback</button>
        <audio id="loopbackAudio" controls autoplay muted></audio>
        <div id="loopbackStatus"></div>
    </div>

    <div id="status">Ready to test...</div>

    <script>
        const socket = io();
        let pc;
        const status = document.getElementById('status');

        function updateStatus(message) {
            status.innerHTML += new Date().toLocaleTimeString() + ': ' + message + '<br>';
            console.log(message);
        }

        socket.on('connect', () => {
            updateStatus('‚úÖ Connected to server');
        });

        async function testDirectAudio() {
            const audio = document.getElementById('testAudio');
            const statusDiv = document.getElementById('directStatus');
            
            try {
                statusDiv.innerHTML = 'Testing direct audio playback...';
                
                // Create a simple tone
                const audioContext = new AudioContext();
                const oscillator = audioContext.createOscillator();
                const destination = audioContext.createMediaStreamDestination();
                
                oscillator.connect(destination);
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
                oscillator.start();
                
                audio.srcObject = destination.stream;
                
                setTimeout(() => {
                    oscillator.stop();
                    statusDiv.innerHTML = '<span class="success">‚úÖ Direct audio test completed</span>';
                }, 2000);
                
                updateStatus('Direct audio test: Generated 440Hz tone for 2 seconds');
                
            } catch (error) {
                statusDiv.innerHTML = `<span class="error">‚ùå Error: ${error.message}</span>`;
                updateStatus(`Direct audio test failed: ${error.message}`);
            }
        }

        async function testWebRTCAudio() {
            const audio = document.getElementById('webrtcAudio');
            const statusDiv = document.getElementById('webrtcStatus');
            
            try {
                statusDiv.innerHTML = 'Testing WebRTC audio reception...';
                updateStatus('Starting WebRTC audio test...');
                
                // Create peer connection
                pc = new RTCPeerConnection({
                    iceServers: [{ urls: "stun:stun.relay.metered.ca:80" }],
                });

                // Add transceiver for receiving audio
                pc.addTransceiver("audio", { direction: "recvonly" });
                updateStatus('Added audio transceiver (recvonly)');

                // Handle incoming tracks
                pc.ontrack = (event) => {
                    updateStatus(`üéµ Track received: ${event.track.kind}, enabled: ${event.track.enabled}, readyState: ${event.track.readyState}`);
                    
                    if (event.streams && event.streams.length > 0) {
                        audio.srcObject = event.streams[0];
                        updateStatus('‚úÖ Audio stream set to audio element');
                        statusDiv.innerHTML = '<span class="success">‚úÖ WebRTC audio track received and playing</span>';
                        
                        // Monitor audio levels
                        try {
                            const audioContext = new AudioContext();
                            const source = audioContext.createMediaStreamSource(event.streams[0]);
                            const analyser = audioContext.createAnalyser();
                            source.connect(analyser);
                            
                            const dataArray = new Uint8Array(analyser.frequencyBinCount);
                            
                            const monitorAudio = () => {
                                analyser.getByteFrequencyData(dataArray);
                                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                                updateStatus(`üéµ Audio level: ${average.toFixed(2)}`);
                                
                                if (average > 0) {
                                    updateStatus('‚úÖ Audio data is flowing!');
                                }
                            };
                            
                            // Monitor for 10 seconds
                            const interval = setInterval(monitorAudio, 1000);
                            setTimeout(() => {
                                clearInterval(interval);
                                updateStatus('Audio monitoring stopped');
                            }, 10000);
                            
                        } catch (err) {
                            updateStatus(`Audio monitoring error: ${err.message}`);
                        }
                    } else {
                        // Create stream from track
                        const stream = new MediaStream([event.track]);
                        audio.srcObject = stream;
                        updateStatus('‚úÖ Audio track wrapped in stream and set to audio element');
                        statusDiv.innerHTML = '<span class="success">‚úÖ WebRTC audio track received (single track)</span>';
                    }
                };

                // Handle ICE candidates
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit("browser-candidate", event.candidate);
                        updateStatus('üßä Sent ICE candidate to server');
                    }
                };

                // Handle connection state changes
                pc.onconnectionstatechange = () => {
                    updateStatus(`üîó Connection state: ${pc.connectionState}`);
                };

                pc.oniceconnectionstatechange = () => {
                    updateStatus(`üßä ICE connection state: ${pc.iceConnectionState}`);
                };

                // Get user media for sending
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => {
                    pc.addTrack(track, stream);
                });
                updateStatus('‚úÖ Added microphone to peer connection');

                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                updateStatus('‚úÖ Created and set local offer');

                // Send offer to server
                socket.emit("browser-offer", offer.sdp);
                updateStatus('‚úÖ Sent offer to server');

                statusDiv.innerHTML = 'Waiting for server response...';
                
            } catch (error) {
                statusDiv.innerHTML = `<span class="error">‚ùå Error: ${error.message}</span>`;
                updateStatus(`WebRTC audio test failed: ${error.message}`);
            }
        }

        async function testMicLoopback() {
            const audio = document.getElementById('loopbackAudio');
            const statusDiv = document.getElementById('loopbackStatus');
            
            try {
                statusDiv.innerHTML = 'Testing microphone loopback...';
                updateStatus('Starting microphone loopback test...');
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audio.srcObject = stream;
                audio.muted = false; // Unmute to hear yourself
                
                updateStatus('‚úÖ Microphone loopback active - you should hear yourself');
                statusDiv.innerHTML = '<span class="success">‚úÖ Microphone loopback active</span>';
                
                // Stop after 5 seconds to avoid feedback
                setTimeout(() => {
                    stream.getTracks().forEach(track => track.stop());
                    audio.srcObject = null;
                    statusDiv.innerHTML = '<span class="warning">‚èπÔ∏è Loopback stopped (prevented feedback)</span>';
                    updateStatus('Microphone loopback stopped');
                }, 5000);
                
            } catch (error) {
                statusDiv.innerHTML = `<span class="error">‚ùå Error: ${error.message}</span>`;
                updateStatus(`Microphone loopback test failed: ${error.message}`);
            }
        }

        // Handle server responses
        socket.on("browser-answer", (sdp) => {
            updateStatus('üì• Received SDP answer from server');
            if (pc) {
                pc.setRemoteDescription(new RTCSessionDescription({ type: "answer", sdp }))
                    .then(() => {
                        updateStatus('‚úÖ Set remote description (server answer)');
                    })
                    .catch(err => {
                        updateStatus(`‚ùå Failed to set remote description: ${err.message}`);
                    });
            }
        });

        socket.on("webrtc-error", (data) => {
            updateStatus(`‚ùå WebRTC error from server: ${data.error}`);
        });
    </script>
</body>
</html> 