<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WhatsApp Voice Call</title>
  <script src="/socket.io/socket.io.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .app-container {
      max-width: 420px;
      margin: 0 auto;
      background: #fff;
      min-height: 100vh;
      box-shadow: 0 0 30px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #25D366 0%, #128C7E 100%);
      color: white;
      padding: 20px;
      text-align: center;
      position: relative;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .header .subtitle {
      font-size: 14px;
      opacity: 0.9;
    }

    .nav-links {
      margin: 10px 0;
    }

    .nav-link {
      display: inline-block;
      color: white;
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .nav-link:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .speaker-toggle {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-left: 10px;
    }

    .speaker-toggle:hover {
      background: rgba(255,255,255,0.3);
    }

    .speaker-toggle.muted {
      background: rgba(255,0,0,0.3);
      border-color: rgba(255,0,0,0.5);
    }

    .speaker-toggle.muted:hover {
      background: rgba(255,0,0,0.4);
    }

    .nav-link i {
      margin-right: 6px;
    }

    .status-bar {
      background: rgba(255,255,255,0.1);
      padding: 8px 20px;
      font-size: 12px;
      text-align: center;
      border-radius: 20px;
      margin: 10px 20px 0;
    }

    .main-content {
      padding: 20px;
      height: calc(100vh - 120px);
      overflow-y: auto;
    }

    .section {
      background: #fff;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.08);
      border: 1px solid #f0f0f0;
    }

    .section-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
      color: #333;
    }

    .input-group {
      margin-bottom: 15px;
    }

    .input-group label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #555;
    }

    .input-field {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e9ecef;
      border-radius: 10px;
      font-size: 16px;
      transition: all 0.3s ease;
      background: #f8f9fa;
    }

    .input-field:focus {
      outline: none;
      border-color: #25D366;
      background: #fff;
      box-shadow: 0 0 0 3px rgba(37, 211, 102, 0.1);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      min-height: 48px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #25D366 0%, #128C7E 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(37, 211, 102, 0.3);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
      color: white;
    }

    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 71, 87, 0.3);
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #5a6268;
      transform: translateY(-2px);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .btn-group .btn {
      flex: 1;
    }

    /* Incoming Call Modal */
    .call-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .call-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 30px;
      border-radius: 25px;
      text-align: center;
      max-width: 350px;
      width: 90%;
      animation: slideUp 0.4s ease;
    }

    @keyframes slideUp {
      from { transform: translate(-50%, 100%); }
      to { transform: translate(-50%, -50%); }
    }

    .call-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, #25D366 0%, #128C7E 100%);
      margin: 0 auto 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.7); }
      70% { transform: scale(1.05); box-shadow: 0 0 0 20px rgba(37, 211, 102, 0); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(37, 211, 102, 0); }
    }

    .caller-info h3 {
      font-size: 24px;
      margin-bottom: 5px;
    }

    .caller-info p {
      font-size: 16px;
      opacity: 0.9;
      margin-bottom: 20px;
    }

    .call-status {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 30px;
    }

    .call-actions {
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    .call-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.3s ease;
    }

    .call-btn.accept {
      background: #28a745;
      color: white;
    }

    .call-btn.reject {
      background: #dc3545;
      color: white;
    }

    .call-btn.mute {
      background: #6c757d;
      color: white;
    }

    .call-btn.skip {
      background: #ffc107;
      color: #212529;
    }

    .call-btn:hover {
      transform: scale(1.1);
    }

    /* Active Call Interface */
    .active-call {
      display: none;
      background: linear-gradient(135deg, #25D366 0%, #128C7E 100%);
      color: white;
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      text-align: center;
    }

    .active-call.show {
      display: block;
    }

    .call-timer {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
    }

    .call-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
    }

    /* Log Section */
    .log-container {
      background: #f8f9fa;
      border-radius: 10px;
      overflow: hidden;
    }

    .log-header {
      background: #343a40;
      color: white;
      padding: 15px;
      display: flex;
      justify-content: between;
      align-items: center;
    }

    .log-title {
      font-weight: 600;
      flex: 1;
    }

    .log-actions {
      display: flex;
      gap: 10px;
    }

    .log-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .log-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .log-content {
      height: 300px;
      overflow-y: auto;
      padding: 15px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 12px;
      line-height: 1.4;
      background: #fff;
    }

    .log-entry {
      margin-bottom: 8px;
      padding: 8px;
      border-radius: 6px;
      border-left: 3px solid #dee2e6;
    }

    .log-entry.info {
      background: #e7f3ff;
      border-left-color: #007bff;
    }

    .log-entry.success {
      background: #d4edda;
      border-left-color: #28a745;
    }

    .log-entry.warning {
      background: #fff3cd;
      border-left-color: #ffc107;
    }

    .log-entry.error {
      background: #f8d7da;
      border-left-color: #dc3545;
    }

    .timestamp {
      color: #6c757d;
      font-weight: 600;
    }

    /* Status Indicators */
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .status-indicator.connected {
      background: #d4edda;
      color: #155724;
    }

    .status-indicator.calling {
      background: #fff3cd;
      color: #856404;
    }

    .status-indicator.error {
      background: #f8d7da;
      color: #721c24;
    }

    .pulse-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse-dot 1.5s infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Audio Visualizer */
    .audio-visualizer {
      display: none;
      height: 60px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      margin: 15px 0;
      position: relative;
      overflow: hidden;
    }

    .audio-visualizer.active {
      display: block;
    }

    .audio-bars {
      display: flex;
      align-items: end;
      justify-content: center;
      height: 100%;
      gap: 3px;
      padding: 10px;
    }

    .audio-bar {
      width: 4px;
      background: white;
      border-radius: 2px;
      animation: audioBar 1s infinite ease-in-out;
    }

    .audio-bar:nth-child(2n) { animation-delay: 0.1s; }
    .audio-bar:nth-child(3n) { animation-delay: 0.2s; }
    .audio-bar:nth-child(4n) { animation-delay: 0.3s; }

    @keyframes audioBar {
      0%, 100% { height: 10px; }
      50% { height: 40px; }
    }

    /* Responsive Design */
    @media (max-width: 480px) {
      .app-container {
        max-width: 100%;
        border-radius: 0;
      }
      
      .main-content {
        padding: 15px;
      }
      
      .section {
        padding: 15px;
      }
    }

    /* Hidden elements */
    .hidden {
      display: none !important;
    }

    /* Audio element (hidden) */
    audio {
      display: none;
    }

    /* Notification styles */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #343a40;
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 1001;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success { background: #28a745; }
    .notification.error { background: #dc3545; }
    .notification.warning { background: #ffc107; color: #333; }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <div class="header">
      <h1><i class="fab fa-whatsapp"></i> WhatsApp Voice Solution</h1>
      <div class="subtitle">Voice Call Bridge System</div>
      <div class="nav-links">
        <a href="recordings.html" class="nav-link">
          <i class="fas fa-microphone"></i> Go to Recordings
        </a>
        <button class="speaker-toggle" id="speaker-toggle" onclick="toggleRinging()" title="Toggle Ringing Tone">
          <i class="fas fa-volume-up"></i>
        </button>
      </div>
      <div class="status-bar" id="connection-status">
        <span class="pulse-dot"></span> Connecting to server...
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      
      <!-- Active Call Section -->
      <div class="active-call" id="active-call">
        <div class="caller-info">
          <h3 id="active-caller-name">John Doe</h3>
          <p id="active-caller-number">+1 234 567 8900</p>
        </div>
        <div class="call-timer" id="call-timer">
          <i class="fas fa-clock"></i> <span id="timer">00:00</span>
        </div>
        <div class="audio-visualizer" id="audio-visualizer">
          <div class="audio-bars">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
          </div>
        </div>
        <div class="call-controls">
          <button class="call-btn mute" id="mute-btn" onclick="toggleMute()">
            <i class="fas fa-microphone"></i>
          </button>
          <button class="call-btn reject" onclick="endCall()">
            <i class="fas fa-phone-slash"></i>
          </button>
        </div>
      </div>

      <!-- Outgoing Call Section -->
      <div class="section">
        <div class="section-title">
          <i class="fas fa-phone"></i> Make WhatsApp Call
        </div>
        
        <div class="input-group">
          <label for="phone-number">Phone Number</label>
          <input type="tel" id="phone-number" class="input-field" placeholder="+1 234 567 8900" />
        </div>
        
        <div class="input-group">
          <label for="caller-name">Caller Name (Optional)</label>
          <input type="text" id="caller-name" class="input-field" placeholder="Your Name" />
        </div>

        <div class="status-indicator hidden" id="call-status">
          <span class="pulse-dot"></span>
          <span id="call-status-text">Ready to call</span>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="call-btn" onclick="makeCall()">
            <i class="fas fa-phone"></i> Call WhatsApp
          </button>
          <button class="btn btn-danger hidden" id="cancel-call-btn" onclick="cancelCall()">
            <i class="fas fa-phone-slash"></i> Cancel
          </button>
        </div>
      </div>

      <!-- Real-time Logs Section -->
      <div class="section">
        <div class="section-title">
          <i class="fas fa-terminal"></i> Real-time Logs
        </div>
        
        <div class="log-container">
          <div class="log-header">
            <div class="log-title">System Logs</div>
            <div class="log-actions">
              <button class="log-btn" onclick="clearLogs()">
                <i class="fas fa-trash"></i> Clear
              </button>
              <button class="log-btn" onclick="exportLogs()">
                <i class="fas fa-download"></i> Export
              </button>
            </div>
          </div>
          <div class="log-content" id="log-content">
            <!-- Logs will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Incoming Call Modal -->
  <div class="call-overlay" id="call-overlay">
    <div class="call-modal">
      <div class="call-avatar">
        <i class="fas fa-user"></i>
      </div>
      <div class="caller-info">
        <h3 id="incoming-caller-name">Unknown Caller</h3>
        <p id="incoming-caller-number">+1 234 567 8900</p>
      </div>
      <div class="call-status">
        <i class="fas fa-phone-volume"></i> Incoming WhatsApp Call
      </div>
      <div class="call-actions">
        <button class="call-btn accept" onclick="answerCall()">
          <i class="fas fa-phone"></i>
        </button>
        <button class="call-btn mute" onclick="muteCall()" id="incoming-mute-btn">
          <i class="fas fa-microphone"></i>
        </button>
        <button class="call-btn reject" onclick="rejectCall()">
          <i class="fas fa-phone-slash"></i>
        </button>
        <button class="call-btn skip" onclick="skipCall()" title="Skip this call">
          <i class="fas fa-forward"></i>
        </button>
      </div>
    </div>
  </div>

  <!-- Hidden Audio Elements -->
  <audio id="ringtone" loop>
    <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEYBjiL1O/QgC4HJHfJ7+qOPwkUXrfq6qxVEQZGn9/vum0cBj2O1/LNeSsFJXfH8N2QQAkUXrfp6qxUEQZIod/vumwbBjyM1/LNeSsFJnjH8N2QQAkTXrfp6qxUEQhKod/wuW0aBjyO1/DKeSsFJnjG8N+RQwkUYLfr7K1WEQZIot/wuW0aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4aBjuN1/DNeSsFJnjG8N+RQwgUYLfr7K1XEQVIot/yuW4=" type="audio/wav">
  </audio>
  <audio id="remote-audio" autoplay></audio>

  <script>
    // Global variables
    const socket = io();
    let pc = null;
    let localStream = null;
    let callStartTime = null;
    let timerInterval = null;
    let activeCallId = null;
    let isCallActive = false;
    let isMuted = false;
    let logs = [];
    
    // Real audio recording variables
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let recordingStream = null;

    // DOM elements
    const connectionStatus = document.getElementById('connection-status');
    const callOverlay = document.getElementById('call-overlay');
    const activeCallSection = document.getElementById('active-call');
    const callStatusIndicator = document.getElementById('call-status');
    const callStatusText = document.getElementById('call-status-text');
    const callBtn = document.getElementById('call-btn');
    const cancelCallBtn = document.getElementById('cancel-call-btn');
    const logContent = document.getElementById('log-content');
    const ringtone = document.getElementById('ringtone');
    const remoteAudio = document.getElementById('remote-audio');
    const muteBtn = document.getElementById('mute-btn');
    const incomingMuteBtn = document.getElementById('incoming-mute-btn');
    const audioVisualizer = document.getElementById('audio-visualizer');

    // Utility functions
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => notification.classList.add('show'), 100);
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 3000);
    }

    function addLog(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = {
        timestamp,
        message,
        type,
        id: Date.now()
      };
      
      logs.push(logEntry);
      
      const logDiv = document.createElement('div');
      logDiv.className = `log-entry ${type}`;
      logDiv.innerHTML = `
        <span class="timestamp">[${timestamp}]</span> ${message}
      `;
      
      logContent.appendChild(logDiv);
      logContent.scrollTop = logContent.scrollHeight;
      
      // Keep only last 100 logs
      if (logs.length > 100) {
        logs.shift();
        logContent.removeChild(logContent.firstChild);
      }
    }

    function updateConnectionStatus(status, message) {
      connectionStatus.innerHTML = `<span class="pulse-dot"></span> ${message}`;
      connectionStatus.className = `status-bar ${status}`;
    }

    function updateCallStatus(status, message) {
      if (status === 'hidden') {
        callStatusIndicator.classList.add('hidden');
      } else {
        callStatusIndicator.classList.remove('hidden');
        callStatusIndicator.className = `status-indicator ${status}`;
        callStatusText.textContent = message;
      }
    }

    function startCallTimer() {
      callStartTime = Date.now();
      const timerElement = document.getElementById('timer');
      
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
        timerElement.textContent = formatTime(elapsed);
      }, 1000);
    }

    function stopCallTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      return callStartTime ? Math.floor((Date.now() - callStartTime) / 1000) : 0;
    }

    // Real Audio Recording Functions
    // RecordRTC-style Audio Recording Variables
    let audioContext = null;
    let mediaStreamSource = null;
    let scriptProcessor = null;
    let isStreamingAudio = false;

    async function startRealAudioRecording(opts = {}) {
      try {
        addLog('üé§ Starting RecordRTC-style audio recording...', 'info');
        console.log('üé§ Requesting microphone access...');
        
        // Get user's microphone with optimized settings for voice calls
        const audioConstraints = opts.audio || {
          sampleRate: 16000,  // 16kHz - optimal for voice calls
          channelCount: 1,   // Mono
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleSize: 16
        };
        
        recordingStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
        console.log('‚úÖ Microphone access granted:', recordingStream);
        addLog('Microphone access granted', 'success');
        
        // Initialize AudioContext for real-time processing
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: audioConstraints.sampleRate
        });
        
        // Resume AudioContext if suspended (required by some browsers)
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
          console.log('üîä AudioContext resumed');
        }
        
        // Create media stream source
        mediaStreamSource = audioContext.createMediaStreamSource(recordingStream);
        
        // Create script processor for real-time audio processing
        // Use smaller buffer size for lower latency and better real-time performance
        const bufferSize = 1024; // Smaller buffer for better real-time performance
        scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
        
        scriptProcessor.onaudioprocess = (event) => {
          if (!isStreamingAudio) return;
          
          // üÜï CRITICAL: Process audio if we're streaming (call accepted or bridge established)
          if (!isStreamingAudio) {
            console.log('‚ö†Ô∏è Not streaming audio, skipping audio processing');
            return;
          }
          
          const inputBuffer = event.inputBuffer;
          const inputData = inputBuffer.getChannelData(0);
          
          // Apply audio processing for better quality
          const processedData = new Float32Array(inputData.length);
          
          // Apply simple noise gate and gain control
          const noiseThreshold = 0.01; // Minimum amplitude to consider as signal
          const gain = 2.0; // Amplify the signal
          
          for (let i = 0; i < inputData.length; i++) {
            let sample = inputData[i];
            
            // Apply noise gate
            if (Math.abs(sample) < noiseThreshold) {
              sample = 0;
            } else {
              // Apply gain and soft limiting
              sample = sample * gain;
              sample = Math.max(-0.95, Math.min(0.95, sample)); // Soft limiting
            }
            
            processedData[i] = sample;
          }
          
          // Convert float32 to int16 PCM for better compatibility
          const pcmData = new Int16Array(processedData.length);
          for (let i = 0; i < processedData.length; i++) {
            pcmData[i] = Math.max(-32768, Math.min(32767, processedData[i] * 32768));
          }
          
          // Send audio data to server in real-time using RecordRTC pattern
          if (socket && socket.connected) {
            const base64 = btoa(String.fromCharCode(...new Uint8Array(pcmData.buffer)));
            socket.emit('real-audio-chunk', {
              audioData: base64,
              size: pcmData.byteLength,
              timestamp: Date.now(),
              sampleRate: audioContext.sampleRate,
              channels: 1,
              type: 'pcm',
              callId: activeCallId || 'unknown' // Include callId if available
            });
            
            // Debug: Log every 100th chunk to avoid spam
            if (Math.random() < 0.01) {
              console.log(`üì§ Sent audio chunk: ${pcmData.byteLength} bytes, callId: ${activeCallId || 'unknown'}`);
            }
          }
        };
        
        // Connect the audio processing chain
        mediaStreamSource.connect(scriptProcessor);
        scriptProcessor.connect(audioContext.destination);
        
        isStreamingAudio = true;
        isRecording = true;
        
        console.log('‚úÖ RecordRTC-style audio streaming started successfully');
        addLog('üé§ Real-time audio streaming started', 'success');
        
        // Also create a backup MediaRecorder for file recording
        const options = {
          mimeType: 'audio/webm;codecs=opus',
          audioBitsPerSecond: 128000
        };
        
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'audio/webm';
        }
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'audio/mp4';
        }
        
        mediaRecorder = new MediaRecorder(recordingStream, options);
        audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        
        mediaRecorder.onstop = () => {
          addLog('Audio recording stopped', 'info');
          stopRealAudioRecording();
        };
        
        mediaRecorder.onerror = (event) => {
          addLog(`Recording error: ${event.error}`, 'error');
        };
        
        // Start MediaRecorder for backup recording
        mediaRecorder.start(1000);
        
      } catch (error) {
        addLog(`Failed to start audio recording: ${error.message}`, 'error');
        console.error('Audio recording error:', error);
      }
    }

    function sendAudioChunkToServer(audioBlob) {
      try {
        console.log(`üì§ Sending audio chunk to server: ${audioBlob.size} bytes`);
        
        // Convert audio blob to base64 and send to server
        const reader = new FileReader();
        reader.onload = () => {
          const audioData = reader.result.split(',')[1]; // Remove data:audio/webm;base64, prefix
          
          console.log(`üì° Emitting real-audio-chunk event, data length: ${audioData.length}`);
          
          socket.emit('real-audio-chunk', {
            callId: activeCallId,
            audioData: audioData,
            timestamp: Date.now(),
            size: audioBlob.size
          });
          
          console.log(`‚úÖ Audio chunk sent successfully: ${audioBlob.size} bytes`);
          addLog(`üì§ Sent audio chunk to server: ${audioBlob.size} bytes`, 'success');
        };
        
        reader.onerror = (error) => {
          console.error('‚ùå FileReader error:', error);
          addLog(`FileReader error: ${error}`, 'error');
        };
        
        reader.readAsDataURL(audioBlob);
        
      } catch (error) {
        console.error('‚ùå Failed to send audio chunk:', error);
        addLog(`Failed to send audio chunk: ${error.message}`, 'error');
      }
    }

    function stopRealAudioRecording() {
      try {
        console.log('üõë Stopping RecordRTC audio recording...');
        console.log('üîç Pre-stop state - isStreamingAudio:', isStreamingAudio, 'isRecording:', isRecording);
        
        // Stop streaming audio first
        isStreamingAudio = false;
        console.log('‚úÖ Set isStreamingAudio to false');
        
        // Clean up AudioContext and processors
        if (scriptProcessor) {
          scriptProcessor.disconnect();
          scriptProcessor = null;
          console.log('‚úÖ Disconnected scriptProcessor');
        }
        
        if (mediaStreamSource) {
          mediaStreamSource.disconnect();
          mediaStreamSource = null;
          console.log('‚úÖ Disconnected mediaStreamSource');
        }
        
        if (audioContext && audioContext.state !== 'closed') {
          audioContext.close();
          audioContext = null;
          console.log('‚úÖ Closed audioContext');
        }
        
        // Stop MediaRecorder
        if (mediaRecorder && isRecording) {
          mediaRecorder.stop();
          isRecording = false;
          console.log('‚úÖ Stopped MediaRecorder');
        }
        
        // Stop recording stream
        if (recordingStream) {
          recordingStream.getTracks().forEach(track => {
            track.stop();
            console.log(`‚úÖ Stopped track: ${track.kind}`);
          });
          recordingStream = null;
          console.log('‚úÖ Cleared recordingStream');
        }
        
        // Send final audio data to server
        if (audioChunks.length > 0) {
          const finalAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          sendFinalAudioToServer(finalAudioBlob);
          console.log(`‚úÖ Sent final audio blob: ${finalAudioBlob.size} bytes`);
        }
        
        console.log('‚úÖ RecordRTC audio recording stopped completely');
        addLog('RecordRTC-style audio recording stopped and sent to server', 'success');
        
      } catch (error) {
        console.error('‚ùå Error stopping audio recording:', error);
        addLog(`Error stopping audio recording: ${error.message}`, 'error');
      }
    }

    function sendFinalAudioToServer(audioBlob) {
      try {
        const reader = new FileReader();
        reader.onload = () => {
          const audioData = reader.result.split(',')[1];
          
          socket.emit('final-audio-recording', {
            callId: activeCallId,
            audioData: audioData,
            duration: audioChunks.length,
            totalSize: audioBlob.size,
            timestamp: Date.now()
          });
          
          addLog(`Final recording sent: ${audioBlob.size} bytes`, 'success');
        };
        reader.readAsDataURL(audioBlob);
        
      } catch (error) {
        addLog(`Failed to send final recording: ${error.message}`, 'error');
      }
    }

    function showIncomingCall(callerName, callerNumber, callId) {
      document.getElementById('incoming-caller-name').textContent = callerName;
      document.getElementById('incoming-caller-number').textContent = callerNumber;
      activeCallId = callId;
      
      callOverlay.style.display = 'block';
      
      // Play ringtone only if ringing is enabled
      if (isRingingEnabled) {
        ringtone.currentTime = 0;
        ringtone.play().catch(e => {
          addLog('Could not play ringtone: ' + e.message, 'warning');
        });
      } else {
        addLog('üîá Ringing disabled - call popup shown without sound', 'info');
      }
      
      addLog(`üìû Incoming call from ${callerName} (${callerNumber})`, 'info');
      showNotification(`Incoming call from ${callerName}`, 'info');
    }

    function hideIncomingCall() {
      callOverlay.style.display = 'none';
      ringtone.pause();
      ringtone.currentTime = 0;
    }

    function showActiveCall(callerName, callerNumber) {
      document.getElementById('active-caller-name').textContent = callerName;
      document.getElementById('active-caller-number').textContent = callerNumber;
      activeCallSection.classList.add('show');
      audioVisualizer.classList.add('active');
      isCallActive = true;
      startCallTimer();
    }

    function hideActiveCall() {
      activeCallSection.classList.remove('show');
      audioVisualizer.classList.remove('active');
      isCallActive = false;
      stopCallTimer();
      
      // Stop real audio recording when call ends
      if (isRecording) {
        stopRealAudioRecording();
      }
      
      // Reset call UI
      updateCallStatus('hidden', '');
      callBtn.disabled = false;
      cancelCallBtn.classList.add('hidden');
      callBtn.classList.remove('hidden');
    }

    function toggleMute() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          isMuted = !audioTrack.enabled;
          
          const muteIcon = muteBtn.querySelector('i');
          muteIcon.className = isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone';
          
          addLog(isMuted ? 'üîá Microphone muted' : 'üé§ Microphone unmuted', 'info');
          showNotification(isMuted ? 'Microphone muted' : 'Microphone unmuted', 'info');
        }
      }
    }

    // Socket event handlers
    socket.on('connect', () => {
      updateConnectionStatus('connected', 'Connected to server');
      addLog('‚úÖ Connected to WhatsApp Bridge server', 'success');
    });

    socket.on('disconnect', () => {
      updateConnectionStatus('error', 'Disconnected from server');
      addLog('‚ùå Disconnected from server', 'error');
    });

    socket.on('connect_error', (error) => {
      updateConnectionStatus('error', 'Connection failed');
      addLog(`‚ùå Connection error: ${error.message}`, 'error');
    });

    socket.on('call-is-coming', ({ callId, callerName, callerNumber }) => {
      showIncomingCall(callerName, callerNumber, callId);
    });

    socket.on('call-accepted', ({ callId, callerName, callerNumber }) => {
      addLog('üìû Call accepted by someone else - hiding popup', 'info');
      hideIncomingCall();
    });

    socket.on('start-browser-timer', () => {
      addLog('üìû Call accepted - starting timer', 'success');
      hideIncomingCall();
    });

    socket.on('outgoing-call-initiated', ({ callId, phoneNumber, callerName }) => {
      addLog(`üìû Outgoing call initiated to ${phoneNumber}`, 'info');
      updateCallStatus('calling', `Calling ${phoneNumber}...`);
      
      callBtn.classList.add('hidden');
      cancelCallBtn.classList.remove('hidden');
      callBtn.disabled = true;
    });

    socket.on('outgoing-call-connected', ({ callId, phoneNumber }) => {
      addLog(`‚úÖ Call connected to ${phoneNumber}`, 'success');
      updateCallStatus('connected', `Connected to ${phoneNumber}`);
      showActiveCall('WhatsApp User', phoneNumber);
      showNotification('Call connected!', 'success');
    });

    socket.on('outgoing-call-rejected', ({ callId, phoneNumber }) => {
      addLog(`‚ùå Call rejected by ${phoneNumber}`, 'error');
      showNotification('Call was rejected', 'error');
      hideActiveCall();
    });

    socket.on('outgoing-call-timeout', ({ callId, phoneNumber }) => {
      addLog(`‚è∞ Call timed out to ${phoneNumber}`, 'warning');
      showNotification('Call timed out', 'warning');
      hideActiveCall();
    });

    socket.on('call-ended', () => {
      const duration = stopCallTimer();
      addLog(`üì¥ Call ended. Duration: ${formatTime(duration)}`, 'info');
      showNotification(`Call ended. Duration: ${formatTime(duration)}`, 'info');
      hideActiveCall();
      hideIncomingCall();
      
      if (pc) {
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
    });

    socket.on('browser-answer', async (sdp) => {
      addLog('üì® Received SDP answer from server', 'info');
      
      if (pc && pc.signalingState !== 'stable') {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp }));
          addLog('‚úÖ SDP answer applied successfully', 'success');
        } catch (error) {
          addLog(`‚ùå Error setting SDP answer: ${error.message}`, 'error');
        }
      }
    });

    socket.on('browser-candidate', async (candidate) => {
      if (pc) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
          addLog('üßä ICE candidate added', 'info');
        } catch (error) {
          addLog(`‚ùå Error adding ICE candidate: ${error.message}`, 'error');
        }
      }
    });

    socket.on('force-webrtc-start', ({ message }) => {
      addLog(`üöÄ Auto-starting WebRTC: ${message}`, 'info');
      if (!pc && isCallActive) {
        startWebRTC();
      }
    });

    socket.on('webrtc-error', ({ error }) => {
      addLog(`‚ùå WebRTC Error: ${error}`, 'error');
      showNotification('WebRTC connection failed', 'error');
    });

    // Server-controlled mic capture lifecycle
    socket.on('start-mic-capture', async (opts) => {
      try {
        addLog('üéµ Server requested mic capture start', 'info');
        if (!isRecording) {
          await startRealAudioRecording(opts || {});
        }
      } catch (e) {
        addLog(`‚ùå Failed to start mic capture: ${e.message}`, 'error');
      }
    });

    socket.on('stop-mic-capture', () => {
      addLog('üõë Server requested mic capture stop', 'warning');
      console.log('üõë Received stop-mic-capture from server');
      console.log('üîç Current state - isRecording:', isRecording, 'isStreamingAudio:', isStreamingAudio);
      
      // üÜï CRITICAL: Stop immediately, don't wait for conditions
      if (isRecording || isStreamingAudio) {
        stopRealAudioRecording();
        console.log('‚úÖ Audio recording stopped successfully');
      } else {
        console.log('‚ö†Ô∏è Audio recording was not active');
      }
      
      // üÜï ADDITIONAL: Force stop any remaining audio processing
      isStreamingAudio = false;
      isRecording = false;
      console.log('üîí Forced audio capture to stop');
    });

    // Listen for real-time log messages from server
    socket.on('realtime-log', (logData) => {
      addLog(logData.message, logData.type);
      console.log('üìù Real-time log from server:', logData);
    });

    // Call control functions
    async function makeCall() {
      const phoneNumber = document.getElementById('phone-number').value.trim();
      const callerName = document.getElementById('caller-name').value.trim() || 'Web Caller';

      if (!phoneNumber) {
        showNotification('Please enter a phone number', 'error');
        return;
      }

      try {
        addLog(`üìû Initiating call to ${phoneNumber}`, 'info');
        
        const response = await fetch('/initiate-call', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ phoneNumber, callerName })
        });

        const result = await response.json();
        if (!result.success) {
          addLog(`‚ùå Call failed: ${result.error}`, 'error');
          showNotification(`Call failed: ${result.error}`, 'error');
          hideActiveCall();
        }
      } catch (error) {
        addLog(`‚ùå Error making call: ${error.message}`, 'error');
        showNotification('Error making call', 'error');
        hideActiveCall();
      }
    }

    function cancelCall() {
      socket.emit('terminate-outbound-call');
      addLog('üî¥ Call cancelled by user', 'warning');
      hideActiveCall();
    }

    function answerCall() {
      socket.emit('accept-call', activeCallId);
      addLog('‚úÖ Call accepted', 'success');
      showActiveCall(
        document.getElementById('incoming-caller-name').textContent,
        document.getElementById('incoming-caller-number').textContent
      );
      hideIncomingCall();
      // Mic capture will start only when server confirms bridge
      startWebRTC();
    }

    function rejectCall() {
      socket.emit('reject-call', activeCallId);
      addLog('‚ùå Call rejected', 'warning');
      hideIncomingCall();
    }

    function muteCall() {
      // For incoming calls, just mute the ringtone
      if (ringtone && !ringtone.paused) {
        ringtone.muted = !ringtone.muted;
        const muteIcon = incomingMuteBtn.querySelector('i');
        muteIcon.className = ringtone.muted ? 'fas fa-volume-mute' : 'fas fa-microphone';
        addLog(ringtone.muted ? 'üîá Ringtone muted' : 'üîä Ringtone unmuted', 'info');
      }
    }

    // Global variable to track ringing state
    let isRingingEnabled = true;

    function toggleRinging() {
      isRingingEnabled = !isRingingEnabled;
      const speakerToggle = document.getElementById('speaker-toggle');
      const icon = speakerToggle.querySelector('i');
      
      if (isRingingEnabled) {
        icon.className = 'fas fa-volume-up';
        speakerToggle.classList.remove('muted');
        addLog('üîä Ringing enabled', 'info');
      } else {
        icon.className = 'fas fa-volume-mute';
        speakerToggle.classList.add('muted');
        addLog('üîá Ringing disabled', 'info');
        // Stop current ringing if any
        if (ringtone && !ringtone.paused) {
          ringtone.pause();
          ringtone.currentTime = 0;
        }
      }
    }

    function skipCall() {
      addLog('‚è≠Ô∏è Call skipped - stopping ringing for this browser', 'info');
      hideIncomingCall();
      // Stop ringing for this browser only
      if (ringtone && !ringtone.paused) {
        ringtone.pause();
        ringtone.currentTime = 0;
      }
    }

    function endCall() {
      if (activeCallId) {
        socket.emit('terminate-call', activeCallId);
      } else {
        socket.emit('terminate-outbound-call');
      }
      addLog('üî¥ Call ended by user', 'warning');
      hideActiveCall();
      hideIncomingCall();
    }

    // WebRTC functions
    async function startWebRTC() {
      try {
        addLog('üöÄ Starting WebRTC connection', 'info');
        
        pc = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.relay.metered.ca:80' }]
        });

        // Set up event handlers
        pc.ontrack = (event) => {
          addLog('üéµ Received remote audio track', 'success');
          
          if (event.streams && event.streams.length > 0) {
            const remoteStream = event.streams[0];
            remoteAudio.srcObject = remoteStream;
            remoteAudio.play().then(() => {
              addLog('üîä Remote audio playing', 'success');
            }).catch(err => {
              addLog(`‚ö†Ô∏è Audio play failed: ${err.message}`, 'warning');
            });

            // Capture remote WhatsApp audio (PCM 8k) and send to server
            try {
              const AudioCtx = window.AudioContext || window.webkitAudioContext;
              const ac = new AudioCtx({ sampleRate: 8000 });
              const src = ac.createMediaStreamSource(remoteStream);
              const processor = ac.createScriptProcessor(4096, 1, 1);
              src.connect(processor);
              processor.connect(ac.destination);
              
              processor.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                const pcm = new Int16Array(input.length);
                for (let i = 0; i < input.length; i++) {
                  let s = input[i];
                  s = Math.max(-1, Math.min(1, s));
                  pcm[i] = s * 32767;
                }
                const buf = new Uint8Array(pcm.buffer);
                const b64 = btoa(String.fromCharCode.apply(null, buf));
                socket.emit('whatsapp-audio-chunk', {
                  callId: activeCallId,
                  audioData: b64,
                  timestamp: Date.now(),
                  size: buf.byteLength
                });
              };
            } catch (err) {
              addLog(`‚ö†Ô∏è Failed to tap remote audio: ${err.message}`, 'warning');
            }
          }
        };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
            socket.emit('browser-candidate', event.candidate);
            addLog('üßä Sent ICE candidate to server', 'info');
        }
      };

      pc.onconnectionstatechange = () => {
          addLog(`üîó WebRTC connection state: ${pc.connectionState}`, 'info');
          if (pc.connectionState === 'connected') {
            addLog('‚úÖ WebRTC connection established', 'success');
            showNotification('Audio connection established', 'success');
          } else if (pc.connectionState === 'failed') {
            addLog('‚ùå WebRTC connection failed', 'error');
            showNotification('Audio connection failed', 'error');
          }
        };

      pc.oniceconnectionstatechange = () => {
          addLog(`üßä ICE connection state: ${pc.iceConnectionState}`, 'info');
        };

        // Add transceiver and get user media
        pc.addTransceiver('audio', { direction: 'sendrecv' });
        
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        addLog('üé§ Microphone access granted', 'success');
        
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
          addLog(`‚ûï Added ${track.kind} track to connection`, 'info');
        });

        // Create and send offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        socket.emit('browser-offer', offer.sdp);
        addLog('üì§ Sent WebRTC offer to server', 'info');

      } catch (error) {
        addLog(`‚ùå WebRTC setup failed: ${error.message}`, 'error');
        showNotification('Microphone access denied or WebRTC failed', 'error');
      }
    }

    // Log management functions
    function clearLogs() {
      logs = [];
      logContent.innerHTML = '';
      addLog('üóëÔ∏è Logs cleared', 'info');
    }

    function exportLogs() {
      const logText = logs.map(log => 
        `[${log.timestamp}] ${log.type.toUpperCase()}: ${log.message}`
      ).join('\n');
      
      const blob = new Blob([logText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `whatsapp-bridge-logs-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      addLog('üìÅ Logs exported successfully', 'success');
      showNotification('Logs exported successfully', 'success');
    }

    // Initialize app
    addLog('üîß WhatsApp Bridge initialized', 'info');
    addLog('üì± Ready to make and receive calls', 'info');

    // Auto-resume audio context on user interaction
    document.addEventListener('click', () => {
      if (window.AudioContext || window.webkitAudioContext) {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            addLog('üîä Audio context resumed', 'info');
          });
        }
      }
    });

    // Handle keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && callOverlay.style.display === 'block') {
        rejectCall();
      }
      if (e.key === 'Enter' && callOverlay.style.display === 'block') {
        answerCall();
      }
      if (e.key === 'm' && isCallActive) {
        toggleMute();
      }
    });
  </script>
</body>
</html>
